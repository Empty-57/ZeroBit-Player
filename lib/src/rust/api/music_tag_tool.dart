// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `edit_cover`, `edit_tags`, `get_cover`, `get_duration_with_win`, `get_tag`, `handle_get_cover_error`, `new`, `render_tags`

Future<AudioMetadata> getMetadata({required String path}) =>
    RustLib.instance.api.crateApiMusicTagToolGetMetadata(path: path);

Future<Uint8List?> getCover({required String path, required int sizeFlag}) =>
    RustLib.instance.api.crateApiMusicTagToolGetCover(
      path: path,
      sizeFlag: sizeFlag,
    );

Future<void> editTags({required String path, required EditableMetadata data}) =>
    RustLib.instance.api.crateApiMusicTagToolEditTags(path: path, data: data);

Future<void> editCover({required String path, required List<int> src}) =>
    RustLib.instance.api.crateApiMusicTagToolEditCover(path: path, src: src);

class AudioMetadata {
  final String title;
  final String artist;
  final String album;
  final String genre;
  final double duration;
  final int? bitrate;
  final int? sampleRate;
  final String path;

  const AudioMetadata({
    required this.title,
    required this.artist,
    required this.album,
    required this.genre,
    required this.duration,
    this.bitrate,
    this.sampleRate,
    required this.path,
  });

  @override
  int get hashCode =>
      title.hashCode ^
      artist.hashCode ^
      album.hashCode ^
      genre.hashCode ^
      duration.hashCode ^
      bitrate.hashCode ^
      sampleRate.hashCode ^
      path.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AudioMetadata &&
          runtimeType == other.runtimeType &&
          title == other.title &&
          artist == other.artist &&
          album == other.album &&
          genre == other.genre &&
          duration == other.duration &&
          bitrate == other.bitrate &&
          sampleRate == other.sampleRate &&
          path == other.path;
}

class EditableMetadata {
  final String? title;
  final String? artist;
  final String? album;
  final String? genre;

  const EditableMetadata({this.title, this.artist, this.album, this.genre});

  @override
  int get hashCode =>
      title.hashCode ^ artist.hashCode ^ album.hashCode ^ genre.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EditableMetadata &&
          runtimeType == other.runtimeType &&
          title == other.title &&
          artist == other.artist &&
          album == other.album &&
          genre == other.genre;
}
